# 核心模块技术设计

<cite>
**本文档中引用的文件**
- [code_searcher.py](file://src/code_searcher.py)
- [search_template.py](file://src/search_template.py)
- [strategies.py](file://src/strategies.py)
- [database.py](file://src/database.py)
- [exporter.py](file://src/exporter.py)
</cite>

## 目录
1. [CodeSearcher 模块](#codesearcher-模块)
2. [SearchTemplate 模块](#searchtemplate-模块)
3. [SearchStrategy 模块](#searchstrategy-模块)
4. [DatabaseManager 模块](#databasemanager-模块)
5. [ExcelExporter 模块](#excelexporter-模块)

## CodeSearcher 模块

`CodeSearcher` 是整个代码搜索工具的核心协调类，负责整合配置、搜索模板、数据库管理和导出功能。其主要职责是初始化各个组件，并通过调用链驱动整个搜索流程。

### 初始化流程分析

`CodeSearcher` 的初始化过程在 `__init__` 方法中完成，该方法接收一个 `SearchConfig` 配置对象作为参数，并据此构建所有依赖组件：

1. **配置注入**：将传入的 `config` 对象保存为实例属性。
2. **搜索模板创建**：使用 `DefaultSearchTemplate(config)` 创建默认的搜索流程模板。
3. **数据库管理器初始化**：通过 `DatabaseManager(config.db_path)` 实例化数据库操作对象，用于持久化搜索结果。
4. **Excel 导出器配置**：创建 `ExcelExporter` 实例，设置最大行数限制（默认 100,000 行），防止生成过大的 Excel 文件。
5. **路径验证**：检查配置中的仓库路径是否存在，若不存在则抛出 `FileNotFoundError` 并记录错误日志。

此初始化流程体现了依赖注入的设计原则，确保了各组件之间的松耦合。

### search 方法调用链

`search()` 方法是启动搜索的入口点，其实现极为简洁，仅包含一行核心逻辑：

```python
return self.search_template.search()
```

该方法将实际的搜索任务完全委托给 `DefaultSearchTemplate` 实例的 `search()` 方法。这种设计遵循了“单一职责”原则，使 `CodeSearcher` 专注于流程控制，而将具体的搜索算法和流程细节交由 `SearchTemplate` 处理。

**Section sources**
- [code_searcher.py](file://src/code_searcher.py#L21-L37)

### save_results 方法调用链

`save_results(matched_results)` 方法负责将搜索得到的结果进行持久化存储，其调用链如下：

1. **数据库保存**：调用 `self.db_manager.save_results(matched_results)` 将结果批量写入 SQLite 数据库。
2. **Excel 导出**：调用 `self.excel_exporter.export_to_excel(matched_results)` 将结果导出为 Excel 文件，支持大文件自动分片。
3. **日志记录**：操作完成后，记录 "结果保存完成" 的信息日志。

该方法展示了典型的组合模式，将多个独立的持久化操作串联起来，对外提供统一的接口。

**Section sources**
- [code_searcher.py](file://src/code_searcher.py#L39-L61)

## SearchTemplate 模块

`SearchTemplate` 类实现了“模板方法”设计模式，定义了代码搜索的标准流程骨架，同时允许子类通过重写钩子方法来定制特定步骤的行为。

### _search 流程总览

`search()` 方法是模板方法的核心，它定义了一个不可变的搜索流程：

1. 输出开始搜索的日志。
2. 调用 `_count_files()` 统计待分析的文件数量。
3. 解析搜索词（`_parse_search_terms()`）。
4. 执行初步搜索（`_perform_initial_search()`）。
5. 如果启用了校验（`config.validate` 为 True），则执行二次校验（`_perform_validation()`）。
6. 返回最终的匹配结果。

这个流程保证了所有基于此模板的搜索都遵循相同的执行顺序。

### _perform_initial_search 钩子方法

`_perform_initial_search(search_terms)` 是一个具体的方法，它利用策略模式，通过调用 `self.strategy.search()` 来执行实际的搜索操作。这里的 `strategy` 是由子类通过 `_create_search_strategy()` 工厂方法创建的。该方法的设计意图是将“如何搜索”的实现细节与“何时搜索”的流程控制解耦。

**Section sources**
- [search_template.py](file://src/search_template.py#L132-L142)

### _perform_validation 钩子方法

`_perform_validation(matched_results, search_terms)` 是一个抽象方法（在基类中为空实现），强制要求所有子类必须提供自己的校验逻辑。其设计意图在于：
- **提高准确性**：初步搜索可能因性能优化而产生误报，二次校验可以对结果进行更严格的文本匹配或上下文分析。
- **灵活性**：不同的搜索场景可能需要不同的校验策略（如并行校验、深度解析等），抽象方法提供了扩展点。

在 `DefaultSearchTemplate` 中，该方法被实现为调用 `parallel_validate` 函数，利用多进程进行高效校验。

**Section sources**
- [search_template.py](file://src/search_template.py#L145-L156)

### _create_search_strategy 钩子方法

`_create_search_strategy()` 同样是一个抽象方法，其设计意图是作为工厂方法，用于创建并返回一个具体的 `SearchStrategy` 实例。这使得 `SearchTemplate` 可以在运行时动态地选择不同的搜索算法（如 Grep 或 Python 原生搜索），而无需修改其内部逻辑，充分体现了策略模式的优势。

**Section sources**
- [search_template.py](file://src/search_template.py#L159-L166)

## SearchStrategy 模块

`SearchStrategy` 是一个抽象基类，定义了所有搜索策略必须实现的接口。通过对比其两个具体实现，可以清晰地看到不同策略的设计差异。

### 策略实现差异对比

| 特性 | GrepSearchStrategy | PythonSearchStrategy |
| :--- | :--- | :--- |
| **底层技术** | 调用系统 `grep` 命令 | 使用 Python 内置函数和正则表达式 |
| **性能** | 通常更快，尤其对于大型仓库 | 相对较慢，但可移植性强 |
| **依赖** | 依赖操作系统安装了 `grep` | 无外部依赖，纯 Python 实现 |
| **容错性** | 若 `grep` 不可用，则自动降级到 `PythonSearchStrategy` | 无 |
| **文件过滤** | 利用 `grep` 的 `--exclude-dir` 和 `--include` 参数 | 在 Python 代码中手动遍历和过滤 |
| **编码处理** | 由 `grep` 自动处理 | 显式指定 `utf-8` 编码读取文件 |
| **异常处理** | 捕获 `subprocess.TimeoutExpired`, `FileNotFoundError` 等 | 捕获 `UnicodeDecodeError`, `PermissionError` 等 |

`GrepSearchStrategy` 优先追求性能，利用了经过高度优化的系统工具；而 `PythonSearchStrategy` 则牺牲了部分性能，换取了跨平台的兼容性和更强的可控性。两者结合，构成了一个健壮且适应性强的搜索策略体系。

**Section sources**
- [strategies.py](file://src/strategies.py#L73-L232)

## DatabaseManager 模块

`DatabaseManager` 类负责与 SQLite 数据库的交互，其核心功能包括数据库初始化和结果持久化。

### SQL 语句构造机制

该模块中的 SQL 语句构造遵循最佳实践：
- **表创建**：使用 `CREATE TABLE IF NOT EXISTS` 语句，确保多次初始化不会报错。
- **索引创建**：为 `file_path` 字段创建索引 (`idx_file_path`)，显著提升后续按文件路径查询的效率。
- **数据插入**：采用 `INSERT INTO ... VALUES (?, ?, ?, ?)` 的预编译参数化查询，有效防止 SQL 注入攻击。
- **批量操作**：使用 `cursor.executemany()` 方法一次性插入所有结果，极大减少了数据库 I/O 次数，提高了写入性能。

### 异常处理机制

该模块采用了全面的异常处理策略：
- **try-except 包裹**：所有数据库操作都被 `try-except` 块包围。
- **具体异常捕获**：虽然示例中捕获的是通用 `Exception`，但其结构允许捕获更具体的异常类型。
- **日志记录**：发生异常时，使用 `logger.error()` 记录详细的错误信息。
- **异常重抛**：在记录日志后，使用 `raise` 将异常向上抛出，确保调用者能够感知到错误，而不是让程序静默失败。

这种机制保证了数据库操作的可靠性和可观测性。

**Section sources**
- [database.py](file://src/database.py#L12-L81)

## ExcelExporter 模块

`ExcelExporter` 类负责将搜索结果安全地导出到 Excel 文件，并处理潜在的格式问题。

### _clean_excel_content 安全处理逻辑

`_clean_excel_content(content)` 方法是保障导出安全性的关键，其处理逻辑分为三步：

1. **无效字符移除**：移除 Excel 单元格名称中禁止使用的特殊字符，包括 `\`, `/`, `?`, `*`, `[`, `]`, `:`。这些字符如果出现在内容中，可能导致 Excel 文件损坏或打开失败。
2. **控制字符清理**：移除 ASCII 码值在 0-31 之间的控制字符（除了制表符 `\t` (9)、换行符 `\n` (10) 和回车符 `\r` (13)）。这些不可见字符常常来自二进制文件或编码错误，会干扰 Excel 的正常显示。
3. **内容长度截断**：检查内容长度是否超过 Excel 单元格的最大字符限制（32,767 个字符）。如果超出，则将其截断至 32,764 个字符并添加 `"..."` 后缀，既保留了主要内容，又避免了溢出错误。

这一系列的安全处理确保了即使原始代码中包含各种特殊字符或超长字符串，也能生成一个稳定、可打开的 Excel 报告文件。

**Section sources**
- [exporter.py](file://src/exporter.py#L128-L149)