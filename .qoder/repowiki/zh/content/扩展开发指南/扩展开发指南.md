# 扩展开发指南

<cite>
**本文档中引用的文件**
- [strategies.py](file://src/strategies.py)
- [search_factory.py](file://src/search_factory.py)
- [validators.py](file://src/validators.py)
- [exporter.py](file://src/exporter.py)
</cite>

## 目录
1. [简介](#简介)
2. [扩展搜索策略](#扩展搜索策略)
3. [实现结果验证器](#实现结果验证器)
4. [扩展导出功能](#扩展导出功能)
5. [测试与验证](#测试与验证)

## 简介
本指南旨在为高级用户提供系统功能扩展的详细说明。通过继承核心抽象类和实现关键接口，开发者可以无缝集成新的搜索算法、增强结果可信度，并支持多种数据导出格式。文档涵盖从类继承到工厂注册的完整流程，并提供可复用的代码模板。

## 扩展搜索策略

### 继承SearchStrategy抽象基类
要添加新的搜索算法（如ripgrep或全文搜索引擎），需创建一个继承自`SearchStrategy`的新类。该基类定义了统一的搜索接口和通用的文件过滤逻辑。

新策略必须实现`search`方法，该方法接收仓库路径、搜索词和正则表达式标志作为参数，并返回结构化的搜索结果列表。同时，可通过调用父类的`_should_ignore_file`方法来遵循系统的忽略规则（基于目录和文件扩展名）。

```mermaid
classDiagram
class SearchStrategy {
+config : SearchConfig
+__init__(config)
+_should_ignore_file(file_path) bool
+search(repo_path, search_terms, is_regex) List[Dict]
}
class GrepSearchStrategy {
+search(repo_path, search_terms, is_regex) List[Dict]
}
class PythonSearchStrategy {
+search(repo_path, search_terms, is_regex) List[Dict]
}
class NewSearchStrategy {
+search(repo_path, search_terms, is_regex) List[Dict]
}
SearchStrategy <|-- GrepSearchStrategy
SearchStrategy <|-- PythonSearchStrategy
SearchStrategy <|-- NewSearchStrategy
```

**图示来源**
- [strategies.py](file://src/strategies.py#L18-L70)
- [strategies.py](file://src/strategies.py#L73-L171)
- [strategies.py](file://src/strategies.py#L174-L232)

### 注册到SearchStrategyFactory
新创建的搜索策略需要在`SearchStrategyFactory`中注册，以便通过配置动态实例化。工厂类使用静态方法`create_strategy`根据策略类型字符串创建对应的策略实例。

为了支持新策略，应在`create_strategy`方法中添加对新策略类型的判断分支。例如，若新增Ripgrep策略，可添加类似`elif strategy_type.lower() == 'ripgrep': return RipgrepSearchStrategy(config)`的条件语句。

```mermaid
sequenceDiagram
participant 配置 as 搜索配置
participant 工厂 as SearchStrategyFactory
participant 策略 as 新搜索策略
配置->>工厂 : create_strategy("new_strategy", config)
工厂->>工厂 : 判断strategy_type
工厂->>策略 : 实例化NewSearchStrategy(config)
策略-->>工厂 : 返回策略实例
工厂-->>配置 : 返回策略实例
```

**图示来源**
- [search_factory.py](file://src/search_factory.py#L14-L51)

**节来源**
- [strategies.py](file://src/strategies.py#L18-L70)
- [search_factory.py](file://src/search_factory.py#L14-L51)

## 实现结果验证器

### 实现ResultValidator接口
为增强搜索结果的可信度，可通过实现`ResultValidator`接口来添加二次校验逻辑。该抽象基类要求实现`validate`方法，该方法接收初步搜索结果、搜索词和正则标志，并返回经过验证的结果。

开发者可根据具体需求实现不同类型的验证器，例如语法树分析、上下文匹配或外部服务验证。验证器可在搜索模板的二次校验阶段被调用，确保返回结果的准确性。

```mermaid
classDiagram
class ResultValidator {
+validate(file_results, search_terms, is_regex) List[Dict]
}
class ParallelResultValidator {
+max_workers : int
+__init__(max_workers)
+validate(file_results, search_terms, is_regex) List[Dict]
}
class CustomResultValidator {
+validate(file_results, search_terms, is_regex) List[Dict]
}
ResultValidator <|-- ParallelResultValidator
ResultValidator <|-- CustomResultValidator
```

**图示来源**
- [validators.py](file://src/validators.py#L13-L29)
- [validators.py](file://src/validators.py#L32-L50)

**节来源**
- [validators.py](file://src/validators.py#L13-L50)

## 扩展导出功能

### 修改ExcelExporter以支持新格式
`ExcelExporter`类负责将搜索结果导出为Excel文件。为支持CSV或JSONL等其他格式，可通过继承该类并重写导出方法来实现。

建议创建新的导出器类（如`CsvExporter`或`JsonlExporter`），继承自通用的导出基类（若存在）或直接实现导出逻辑。新导出器应保留原有的数据准备流程（`export_data`构建），但替换底层的文件写入逻辑。

例如，CSV导出可使用Python内置的`csv`模块，而JSONL导出则逐行写入JSON对象。同时，应保持对大数据量的分块处理能力，避免内存溢出。

```mermaid
flowchart TD
A["开始导出"] --> B["准备导出数据"]
B --> C{"数据量 > 最大行数?"}
C --> |否| D["单文件导出"]
C --> |是| E["分块导出"]
D --> F["调用格式专用写入方法"]
E --> G["循环: 分块数据"]
G --> H["调用格式专用写入方法"]
H --> I["记录导出进度"]
I --> J["结束"]
F --> J
```

**图示来源**
- [exporter.py](file://src/exporter.py#L20-L57)
- [exporter.py](file://src/exporter.py#L59-L77)
- [exporter.py](file://src/exporter.py#L79-L120)

**节来源**
- [exporter.py](file://src/exporter.py#L15-L149)

## 测试与验证
新增功能应通过单元测试和集成测试进行验证。测试应覆盖正常流程、边界条件和异常处理。对于新搜索策略，需验证其与现有配置的兼容性；对于新导出格式，需确保输出文件可被标准工具正确读取。所有测试应模拟真实使用场景，确保新增功能能够无缝集成到现有系统中。